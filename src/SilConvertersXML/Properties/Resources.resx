<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="dataGridViewConverterMappingHelp" xml:space="preserve">
    <value>This grid displays the conversion "instructions" that you've created. The 'XPath' column shows the XPath syntax of the requested change(s). 
The 'Example Data' column shows a data sample from the selected records of the xml file. The button in the 'Converter' column allows you to 
specify which converter from the system repository to use to convert the data. Finally, the 'Example Results' column shows the results of 
the conversion of the sample data using the configured converter.

If you click on a cell in the 'Example Data' column, it will sequence through all the data in the file that match the given XPath statement (e.g. to 
check the conversion results).

Once you've configured which system converter(s) to use to convert the data for each XPath statement, you can save those mappings by choosing the 
'Converter Mappings' menu item and then click the 'Save' item.

 o The 'Converter Mappings', 'Load' menu item can be used to load a saved mapping from a previous session.
 o The 'Converter Mappings', 'New' menu item can be used to reset all the mappings.
 o The 'Converter Mappings', 'Set Default Converter' menu item can be used to assign a single converter to all the unconfigured rows with one action.

Once you've chosen a converter, it is also retentive so that if you right-click on another converter name button, the same converter will be applied to 
the new row as well.

If instead of a system converter you want to replace the data value with a fixed string, then click the converter name button and then click the 
'Cancel' button on the Select Converter dialog box. You will be given the opportunity to create a fixed value replacement rule. 

To remove a configured converter from a particular field altogether, click the converter name button, click the 'Cancel' button, and select "No" when 
asked if you want to add a fixed value replacment rule. As with system converters, subsequently, the right-mouse button alone will repeat either the 
fixed value replacement rule or the converter removal for other fields.

To remove a requested conversion (i.e. a row in the table), select the entire row by clicking on the row header (left side) and press the delete key. 
The delete key will also work to remove the last row whether it is selected or not.

To actually perform the conversion and save the results, click the 'Convert and Save XML Document' button at the bottom of the window (or the 
equivalent on the 'File' menu). The conversion "instructions" in the rows of the table will be executed one-by-one in top-to-bottom order to convert 
the data in the file. After all the conversion instructions are completed, you will be given an opportunity to save the file.
    </value>
  </data>
  <data name="flowLayoutPanelConstraintTypeHelp" xml:space="preserve">
    <value>These buttons allow you to specify the type of filter you want to add. Possible values include:

 o Presence: If this is checked, then the filter will match those records for which the named item is present.
    (for example: "//books/book[@subtitle]" ; select all book records which have an overt subtitle attribute)
 
 o Absence: If this is checked, then the filter will match those records for which the named item is absent.
    (for example: "//books/book[not(@subtitle)]" ; select all book records which do not have an overt subtitle attribute)
 
 o Limit to specific value(s): If this is checked, then all of the values that the named item has in the file will be 
    displayed in the list box below from which you can choose the one(s) you want. Check the box next to the items 
    in the list that represent the values you want to filter on. The filter will match only those records for which the 
    named item equals the value(s) chosen.
    (for example: "//books/book[title = 'Prince Caspian']" ; selects all 'book' elements that contains a title element 
        with the value 'Prince Caspian')
        
    If you click on an item twice (or right-click once) it will become 'gray checked' which means the negation of the 
    value.
    
 o Previous constraint: If this is checked, then all of the previous constraints you've created will be displayed in 
    the list box below from which you can choose the one you want. This is useful for creating complex XPath queries 
    with variable constraints rather than literal ones.
    (for example: you could create a constraint to find the name (attributes) of all book authors that are from Cleveland:
    
    //authors/author[@city = 'Cleveland']/@name
    
    Then you can use that previous constraint in a subsequent constraint on the 'author' attribute of the 'book' element:
    
    "//books/book[//authors/author[@city = 'Cleveland']/@name = @author]" ; selects all of the book 
        elements whose authors are from the city of Cleveland)
        
    Note: no error or type checking is done, so you must insure that the query you enter makes sense.

 o Manually entered: If this is checked, then you will be given the opportunity to manually enter in an xpath filter
    constraint. 

    Note: no error or type checking is done, so you must insure that the query you enter makes sense.
    </value>
  </data>
  <data name="checkedListBoxHelp" xml:space="preserve">
    <value>This is the list of all possible values of the named item in the current file. 

You can choose one or more values so that the data conversion will only be done for those items that match the filter 
condition. If you don't select an item from the list, then the filter will be simply the *presence* of the item.

Element filtering:
   //books/book[title] ; selects all 'book' elements that contain a title element
   //books/book[title = 'Prince Caspian'] ; selects all 'book' elements that contains a title element with the value 'Prince Caspian'
   
Attribute filtering:
   //books/book[@author] ; selects all the 'book' elements that have an overt 'author' attribute
   //books/book[@author = 'C. S. Lewis'] ; selects all the 'book' elements that have a 'author' attribute with a value of 'C. S. Lewis'
   
Multiple conditions:
   //font[@name = 'SILDoulos IPA93' or @name = 'SILManuscript IPA93' or @name = 'SILSophia IPA93'] ; select the font
        elements which have a name attribute of 'SILDoulos IPA93', 'SILManuscript IPA93', or 'SILSophia IPA93')
    </value>
  </data>
  <data name="listBoxViewDataHelp" xml:space="preserve">
    <value>This list shows all of the data for the selected item in the tree 
to the left. Right-click on an item in the tree to select it.

If you want to set the font to be used in this list, 
then right-click on the list and the font dialog will 
be displayed for you to choose from.
    </value>
  </data>
  <data name="treeViewXmlDocHelp" xml:space="preserve">
    <value>This window shows all the unique XML elements/attributes in the XML file (c.f. an XML schema).

In this pane, you can:
 o Right-click on a tree item (not the checkbox) and all of the data for that field will be displayed in the listbox to 
    the right. You can display either "element" or "attribute" items. However, element items must not have any sub-elements 
    (or there's no data to display).
    
 o Left-click on a tree item (not the checkbox) in order to select that item for conversion using a converter from the 
    system repository. The item will appear in the table at the bottom for you to choose the converter to use.
    
 o If you want to constrain either of the above actions to apply only to certain records in the file, then *before* clicking 
    on the item, first check the box(es) next to the *constraining* items. Then when you click on the item to be constrained, 
    you will be presented with a dialog box in which you can specify the constraint value(s).
    
    Note that you can include the same field for conversion more than once with different constraints.
    
No filtering:
   //books/book/title ; selects the 'title' element(s) of the 'book' element in the 'books' (collection) element

Element filtering:
   //books/book[title] ; selects all 'book' elements that contain a title element
   //books/book[title = 'Prince Caspian'] ; selects all 'book' elements that contains a title element with the value 'Prince Caspian'
   
Attribute filtering:
   //books/book[@author] ; selects all the 'book' elements that have an overt 'author' attribute
   //books/book[@author = 'C. S. Lewis'] ; selects all the 'book' elements that have an 'author' attribute with a value of 'C. S. Lewis'
   
Multiple conditions:
   //font[@name = 'SILDoulos IPA93' or @name = 'SILManuscript IPA93' or @name = 'SILSophia IPA93'] ; select the font
        elements which have a name attribute of 'SILDoulos IPA93', 'SILManuscript IPA93', or 'SILSophia IPA93')
    </value>
  </data>
</root>