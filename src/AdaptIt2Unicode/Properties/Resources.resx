<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ConversionCompleteString" xml:space="preserve">
    <value>
The conversion of the Adapt It project configuration file and knowledge bases 
is complete! The next time you open AdaptIt Unicode, your new Unicode project 
'{0}' will be available.

If you would like the adapted texts to be converted to Unicode as well, then 
click the 'Retry' button below.

However beware: only the SFM fields that aren't filtered will be converted! If you
have legacy data in filtered SFM fields, that data will not be converted to Unicode
(and will likely be unrecoverable after that). 

If you need better control over the conversion process, it is recommended that you 
manually export the file(s) with the regular (Legacy) version of AdaptIt as either 
RTF or SFM files, and use SILConverters' Bulk Word document converter or Bulk SFM 
file converter applications, respectively, to convert them.

To turn filtering on or off for certain SFM fields, click 'Edit', 'Preferences' in
Adapt It and using the 'Filtering' tab before attempting the conversion here.
</value>
  </data>
  <data name="FilteredFieldConversionHelp" xml:space="preserve">
    <value>
This table lists all of the filtered fields found in the current document. Check the box in the 
'Convert' column for all fields that contain legacy data in the Source language. Those fields 
will be converted to Unicode using the configured Source language converter.

If a field contains English data (e.g. an English back translation) or arabic numeral data 
(e.g. verse or chapter numbers), then they don't need to be checked because such Ascii data 
are already in the proper format (aka. UTF-8).

If you checked the box on installation that said, "I am using USFM or SILPNG", then certain 
SFM fields will not be shown in this list even if they occur in the filtered part of your 
imported SFM documents. These SFM fields (c.f. \f* (footnote) and \x* (cross-reference)) will 
automatically be converted using the source language converter. 

If you want more control over which fields are converted or not (e.g. if you aren't using USFM
or SILPNG), then you can edit the Windows registry and change the key 
HKEY_CURRENT_USER\Software\SIL\AdaptIt2Unicode[UsingUSFM] to be equal to "No" 
instead of "Yes". Then all of the filtered SF markers encountered will be listed here for you 
to select whether they are to be converted or not.

You can click on the cells in the 'Example Data' column to show other examples.

Note that the 'Example Results' column shows what the result would look like only if 
you check the box in the 'Convert' column. If you don't check the 'Convert' box, then 
the data will remain as it is in the 'Example Data' column.

So, if you see gibberish in the 'Example Data' column (which might be 'English' data 
being displayed with a legacy font), then you probably want to convert such fields. 
If the 'Example Results' column displays gibberish, then you probably don't want to 
convert such fields.

When you're finished, click 'OK' to process the adaptation file(s) with these settings.
    </value>
  </data>
</root>